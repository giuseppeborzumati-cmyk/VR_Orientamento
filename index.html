<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DreamBuilders VR - Orientamento Immersivo</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Arial', sans-serif; }
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            color: white; z-index: 10; pointer-events: none;
            transition: opacity 1s;
        }
        h1 { font-size: 3rem; text-shadow: 0 0 20px #00d2ff; letter-spacing: 5px; text-transform: uppercase; margin-bottom: 10px; text-align: center;}
        p { font-size: 1.2rem; color: #aaa; text-align: center; max-width: 600px;}
        .start-btn {
            margin-top: 30px; padding: 15px 40px; font-size: 1.5rem;
            background: linear-gradient(90deg, #ff00cc, #3333ff);
            border: none; border-radius: 50px; color: white; cursor: pointer;
            pointer-events: auto; box-shadow: 0 0 30px rgba(255, 0, 204, 0.5);
            transition: transform 0.2s;
        }
        .start-btn:hover { transform: scale(1.1); }
        
        /* HUD per quando non si è in VR */
        #hud {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            color: white; font-size: 14px; opacity: 0.6; pointer-events: none;
        }
    </style>
    <!-- Import Three.js e VRButton -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="overlay">
        <h1>Dream Builders</h1>
        <p>Collega il visore o usa il mouse.<br>Il tuo futuro si costruisce ora.</p>
        <button id="startBtn" class="start-btn">INIZIA L'ESPERIENZA</button>
    </div>
    <div id="hud">Clicca sugli oggetti per attivarli • Premi ESC per tornare alla Lobby</div>

    <script type="module">
        import * as THREE from 'three';
        import { VRButton } from 'three/addons/webxr/VRButton.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';

        // --- VARIABILI GLOBALI ---
        let scene, camera, renderer, controls;
        let raycaster, intersected;
        const pointer = new THREE.Vector2();
        let currentRoom = "lobby"; // lobby, moda, science, cat, rim
        let interactiveObjects = []; // Lista oggetti cliccabili
        let animationMixers = [];
        
        // Gruppo contenitore per pulire la scena facilmente
        let worldGroup = new THREE.Group();

        // Font
        let loadedFont = null;

        // Colori Temi
        const THEMES = {
            lobby: { color: 0xffffff, sky: 0x111111 },
            moda: { color: 0xff00cc, sky: 0x220011, wall: 0xffb6c1 },
            science: { color: 0x00ff88, sky: 0x001105, wall: 0x003311 },
            cat: { color: 0xffaa00, sky: 0x110a00, wall: 0x442200 },
            rim: { color: 0x0088ff, sky: 0x000a11, wall: 0x001133 }
        };

        init();

        function init() {
            // SCENA
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111111);
            scene.fog = new THREE.FogExp2(0x111111, 0.02);
            scene.add(worldGroup);

            // CAMERA
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 1.6, 5); // Altezza occhi utente standard

            // RENDERER
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true; // ABILITA VR
            document.body.appendChild(renderer.domElement);
            document.body.appendChild(VRButton.createButton(renderer));

            // CONTROLLI (Per Desktop)
            controls = new OrbitControls(camera, renderer.domElement);
            controls.target.set(0, 1.6, 0);
            controls.update();

            // LUCI
            const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1); 
            scene.add(hemiLight);

            // INTERAZIONE
            raycaster = new THREE.Raycaster();
            
            // CARICAMENTO FONT E START
            const loader = new FontLoader();
            loader.load('https://cdn.jsdelivr.net/npm/three@0.160.0/examples/fonts/helvetiker_bold.typeface.json', function (font) {
                loadedFont = font;
                document.getElementById('startBtn').addEventListener('click', () => {
                    document.getElementById('overlay').style.opacity = 0;
                    setTimeout(() => document.getElementById('overlay').remove(), 1000);
                    buildLobby();
                });
            });

            // EVENTI
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('click', onClick);
            
            // CONTROLLER VR (Opzionale per complessità, usiamo raycaster su sguardo/click)
            
            renderer.setAnimationLoop(render);
        }

        // --- COSTRUTTORI DELLE STANZE ---

        function clearWorld() {
            // Rimuove tutto tranne luci e camera
            while(worldGroup.children.length > 0){ 
                worldGroup.remove(worldGroup.children[0]); 
            }
            interactiveObjects = [];
        }

        // 1. LOBBY
        function buildLobby() {
            clearWorld();
            currentRoom = "lobby";
            scene.background = new THREE.Color(THEMES.lobby.sky);
            scene.fog.color.setHex(THEMES.lobby.sky);

            // Pavimento griglia infinita
            const grid = new THREE.GridHelper(50, 50, 0x444444, 0x111111);
            worldGroup.add(grid);

            createText("SCEGLI IL TUO FUTURO", 0, 4, -5, 0.5, 0xffffff);

            // Portali
            createPortal("SCIENZE APPLICATE", -3, 1.5, -3, THEMES.science.color, () => buildRoom("science"));
            createPortal("SISTEMA MODA", 3, 1.5, -3, THEMES.moda.color, () => buildRoom("moda"));
            createPortal("C.A.T. (Costruzioni)", -3, 1.5, 2, THEMES.cat.color, () => buildRoom("cat"));
            createPortal("MARKETING (RIM)", 3, 1.5, 2, THEMES.rim.color, () => buildRoom("rim"));
        }

        function createPortal(label, x, y, z, color, callback) {
            const geo = new THREE.IcosahedronGeometry(0.8, 0);
            const mat = new THREE.MeshPhongMaterial({ 
                color: color, 
                emissive: color, 
                emissiveIntensity: 0.5,
                wireframe: true 
            });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(x, y, z);
            
            // Animazione rotazione
            mesh.userData = { 
                rotate: true, 
                callback: callback,
                isPortal: true
            };

            worldGroup.add(mesh);
            interactiveObjects.push(mesh);

            // Testo sotto
            createText(label, x, y - 1.2, z, 0.2, color);
            
            // Particles sotto il portale
            const pGeo = new THREE.BufferGeometry();
            const pCount = 20;
            const pPos = new Float32Array(pCount * 3);
            for(let i=0; i<pCount*3; i++) pPos[i] = (Math.random() - 0.5) * 1;
            pGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
            const pMat = new THREE.PointsMaterial({color: color, size: 0.1});
            const particles = new THREE.Points(pGeo, pMat);
            particles.position.set(x, 0.1, z);
            worldGroup.add(particles);
        }

        // 2. COSTRUTTORE GENERALE STANZA
        function buildRoom(type) {
            clearWorld();
            currentRoom = type;
            const theme = THEMES[type];
            
            scene.background = new THREE.Color(theme.sky);
            scene.fog.color.setHex(theme.sky);

            // --- EFFETTO GENESI (ANIMAZIONE MURI) ---
            // Pavimento
            const floorGeo = new THREE.PlaneGeometry(20, 20, 20, 20);
            const floorMat = new THREE.MeshPhongMaterial({ color: 0x111111, wireframe: true });
            const floor = new THREE.Mesh(floorGeo, floorMat);
            floor.rotation.x = -Math.PI / 2;
            worldGroup.add(floor);

            // Muri che salgono (Genesi)
            const wallGeo = new THREE.BoxGeometry(1, 4, 20);
            const wallMat = new THREE.MeshPhongMaterial({ color: theme.wall, transparent: true, opacity: 0.8 });
            
            const wallLeft = new THREE.Mesh(wallGeo, wallMat);
            wallLeft.position.set(-10, -2, 0); // Parte da sotto terra
            worldGroup.add(wallLeft);

            const wallRight = new THREE.Mesh(wallGeo, wallMat);
            wallRight.position.set(10, -2, 0);
            worldGroup.add(wallRight);

            // Animazione Muri
            animateProperty(wallLeft.position, 'y', 2, 1000);
            animateProperty(wallRight.position, 'y', 2, 1000);

            // Pulsante Indietro
            createButton("TORNA ALLA LOBBY", 0, 0.5, 5, 0xff0000, buildLobby);

            // --- CONTENUTO SPECIFICO PER INDIRIZZO ---
            if (type === "moda") buildModaContent(theme.color);
            if (type === "science") buildScienceContent(theme.color);
            if (type === "cat") buildCatContent(theme.color);
            if (type === "rim") buildRimContent(theme.color);
        }

        // --- STANZE SPECIFICHE ---

        function buildModaContent(color) {
            createText("SISTEMA MODA", 0, 4, -8, 1, color);
            
            // La Passerella
            const runwayGeo = new THREE.BoxGeometry(4, 0.2, 12);
            const runwayMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.1 });
            const runway = new THREE.Mesh(runwayGeo, runwayMat);
            runway.position.set(0, 0.1, -2);
            worldGroup.add(runway);

            // Manichini Astratti (Cilindri e Sfere)
            for(let i=0; i<3; i++) {
                const group = new THREE.Group();
                const body = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 1.5, 16), new THREE.MeshPhongMaterial({color: color}));
                const head = new THREE.Mesh(new THREE.SphereGeometry(0.25), new THREE.MeshPhongMaterial({color: 0xffffff}));
                head.position.y = 0.9;
                group.add(body, head);
                group.position.set((i-1)*2, 1, -4 - i);
                
                // Interazione: Clicca per cambiare colore
                group.userData = { 
                    clickable: true, 
                    action: () => { 
                        body.material.color.setHex(Math.random() * 0xffffff); 
                    }
                };
                interactiveObjects.push(group); // Rendiamo l'intero gruppo cliccabile (in una app complessa servirebbe box invisibile)
                interactiveObjects.push(body); // Hack semplice
                
                worldGroup.add(group);
            }

            // Pannelli Info
            createPanel("DESIGN", "Creazione bozzetti\ne stile", -4, 2, -2);
            createPanel("TESSUTI", "Merceologia tessile\ne tecnologia", 4, 2, -2);
        }

        function buildScienceContent(color) {
            createText("SCIENZE APPLICATE", 0, 4, -8, 0.8, color);

            // Atomo Gigante Centrale interattivo
            const nucGeo = new THREE.IcosahedronGeometry(1, 1);
            const nucMat = new THREE.MeshPhongMaterial({ color: color, wireframe: true });
            const nucleus = new THREE.Mesh(nucGeo, nucMat);
            nucleus.position.set(0, 2, -3);
            nucleus.userData = {
                spin: true,
                clickable: true,
                action: () => { nucleus.scale.multiplyScalar(1.2); setTimeout(()=>nucleus.scale.multiplyScalar(1/1.2), 200); }
            };
            worldGroup.add(nucleus);
            interactiveObjects.push(nucleus);

            // Elettroni
            for(let i=0; i<10; i++) {
                const el = new THREE.Mesh(new THREE.SphereGeometry(0.1), new THREE.MeshBasicMaterial({color: 0xffffff}));
                nucleus.add(el);
                // Animazione complessa gestita nel render loop
                el.userData = { offset: i, speed: 0.02 + Math.random()*0.05 };
            }

            createPanel("INFORMATICA", "Coding e\nProblem Solving", -3, 1.5, 0);
            createPanel("LABORATORIO", "Chimica e Fisica\nSperimentale", 3, 1.5, 0);
        }

        function buildCatContent(color) {
            createText("COSTRUZIONI (C.A.T.)", 0, 4, -8, 0.8, color);

            // Blocchi che formano una casa
            const blockSize = 0.5;
            for(let x=-2; x<=2; x++) {
                for(let y=0; y<5; y++) {
                    if(Math.random() > 0.3) { // Alcuni blocchi mancano (in costruzione)
                        const box = new THREE.Mesh(
                            new THREE.BoxGeometry(blockSize, blockSize, blockSize),
                            new THREE.MeshStandardMaterial({color: 0xcd7f32})
                        );
                        box.position.set(x*blockSize*1.1, y*blockSize*1.1 + 0.5, -4);
                        
                        // Animazione "caduta dal cielo"
                        const targetY = box.position.y;
                        box.position.y += 10 + Math.random()*5;
                        animateProperty(box.position, 'y', targetY, 1500 + x*100);
                        
                        worldGroup.add(box);
                    }
                }
            }

            // Gru Interattiva (Semplificata)
            const crane = new THREE.Mesh(new THREE.BoxGeometry(0.2, 4, 0.2), new THREE.MeshPhongMaterial({color: 0xffff00}));
            crane.position.set(3, 2, -4);
            worldGroup.add(crane);
            const jib = new THREE.Mesh(new THREE.BoxGeometry(3, 0.2, 0.2), new THREE.MeshPhongMaterial({color: 0xffff00}));
            jib.position.y = 1.8;
            jib.position.x = -1;
            crane.add(jib);

            createPanel("CAD & BIM", "Progettazione\nDigitale 3D", -3, 2, 0);
            createPanel("CANTIERE", "Sicurezza e\nGestione", 3, 2, 0);
        }

        function buildRimContent(color) {
            createText("MARKETING - R.I.M.", 0, 4, -8, 0.8, color);

            // Mappamondo Olografico
            const globe = new THREE.Mesh(
                new THREE.SphereGeometry(1.5, 32, 32),
                new THREE.MeshPhongMaterial({color: 0x001133, emissive: 0x0044ff, emissiveIntensity: 0.3, wireframe: true})
            );
            globe.position.set(0, 2, -3);
            globe.userData = { spin: true };
            worldGroup.add(globe);

            // Linee di connessione (Dati) che escono dal globo
            const linesMat = new THREE.LineBasicMaterial({ color: 0x00ffff });
            for(let i=0; i<20; i++) {
                const pts = [];
                pts.push(new THREE.Vector3(0, 2, -3)); // Centro
                pts.push(new THREE.Vector3((Math.random()-0.5)*10, (Math.random()-0.5)*5 + 2, (Math.random()-0.5)*5 - 3));
                const lineGeo = new THREE.BufferGeometry().setFromPoints(pts);
                const line = new THREE.Line(lineGeo, linesMat);
                worldGroup.add(line);
            }

            createPanel("ECONOMIA", "Mercati\nGlobali", -3.5, 1.5, -1);
            createPanel("LINGUE", "English, Francais\nEspanol", 3.5, 1.5, -1);
        }

        // --- HELPER FUNCTIONS ---

        function createText(str, x, y, z, size, color) {
            if(!loadedFont) return;
            const geo = new TextGeometry(str, { font: loadedFont, size: size, height: 0.05 });
            geo.center();
            const mat = new THREE.MeshBasicMaterial({ color: color });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(x, y, z);
            worldGroup.add(mesh);
        }

        function createPanel(title, sub, x, y, z) {
            // Sfondo pannello
            const pGeo = new THREE.PlaneGeometry(2, 1.2);
            const pMat = new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.7, side: THREE.DoubleSide, border: true });
            const panel = new THREE.Mesh(pGeo, pMat);
            panel.position.set(x, y, z);
            panel.lookAt(0, 1.6, 5); // Guarda sempre verso l'utente (inizio)
            
            // Bordo neon
            const borderGeo = new THREE.EdgesGeometry(pGeo);
            const borderMat = new THREE.LineBasicMaterial({ color: 0xffffff });
            const border = new THREE.LineSegments(borderGeo, borderMat);
            panel.add(border);

            worldGroup.add(panel);

            // Testo (Approssimato con TextGeometry per semplicità in file singolo)
            if(loadedFont) {
                const tGeo = new TextGeometry(title, { font: loadedFont, size: 0.15, height: 0.01 });
                tGeo.center();
                const tMesh = new THREE.Mesh(tGeo, new THREE.MeshBasicMaterial({color: 0xffffff}));
                tMesh.position.y = 0.2;
                panel.add(tMesh);

                const sGeo = new TextGeometry(sub, { font: loadedFont, size: 0.1, height: 0.01 });
                sGeo.center();
                const sMesh = new THREE.Mesh(sGeo, new THREE.MeshBasicMaterial({color: 0xaaaaaa}));
                sMesh.position.y = -0.2;
                panel.add(sMesh);
            }
        }

        function createButton(text, x, y, z, color, cb) {
            const btnGeo = new THREE.BoxGeometry(1.5, 0.5, 0.1);
            const btnMat = new THREE.MeshPhongMaterial({ color: color });
            const btn = new THREE.Mesh(btnGeo, btnMat);
            btn.position.set(x, y, z);
            
            if(loadedFont) {
                const tGeo = new TextGeometry(text, { font: loadedFont, size: 0.1, height: 0.01 });
                tGeo.center();
                const tMesh = new THREE.Mesh(tGeo, new THREE.MeshBasicMaterial({color: 0xffffff}));
                tMesh.position.z = 0.06;
                btn.add(tMesh);
            }

            btn.userData = { clickable: true, action: cb };
            interactiveObjects.push(btn);
            worldGroup.add(btn);
        }

        function animateProperty(obj, prop, target, duration) {
            const start = obj[prop];
            const startTime = Date.now();
            
            function update() {
                const now = Date.now();
                const progress = Math.min((now - startTime) / duration, 1);
                // Easing easeOutCubic
                const ease = 1 - Math.pow(1 - progress, 3); 
                
                obj[prop] = start + (target - start) * ease;
                
                if(progress < 1) requestAnimationFrame(update);
            }
            update();
        }

        function onClick(event) {
            // Gestione click mouse e VR (base)
            pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
            pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(pointer, camera);
            const intersects = raycaster.intersectObjects(interactiveObjects, true); // true = recursive

            if (intersects.length > 0) {
                // Trova l'oggetto principale con userData
                let target = intersects[0].object;
                while(!target.userData.clickable && !target.userData.isPortal && target.parent) {
                    target = target.parent;
                }

                if (target.userData.callback) target.userData.callback();
                if (target.userData.action) target.userData.action();
            }
        }

        // --- RENDER LOOP ---

        function render(time) {
            // Animazioni costanti
            interactiveObjects.forEach(obj => {
                if(obj.userData.rotate) {
                    obj.rotation.x += 0.01;
                    obj.rotation.y += 0.01;
                }
                if(obj.userData.spin) {
                    obj.rotation.y += 0.005;
                    // Se ha elettroni
                    obj.children.forEach(child => {
                         if(child.userData.speed) {
                             const t = time / 1000;
                             child.position.x = Math.cos(t * 2 + child.userData.offset) * 1.2;
                             child.position.z = Math.sin(t * 2 + child.userData.offset) * 1.2;
                             child.position.y = Math.sin(t * 4 + child.userData.offset) * 1.2;
                         }
                    });
                }
            });

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

    </script>
</body>
</html>
